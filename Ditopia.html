<!DOCTYPE html>
<!--
 @license
 Copyright 2019 Google LLC. All Rights Reserved.
 SPDX-License-Identifier: Apache-2.0
-->
<html>
  <head>
    <title>Ditopia</title>
    <style>/**
        * @license
        * Copyright 2019 Google LLC. All Rights Reserved.
        * SPDX-License-Identifier: Apache-2.0
        */
       /* 
        * Always set the map height explicitly to define the size of the div element
        * that contains the map. 
        */
       #map {
         height: 100%;
       }
       
       /* 
        * Optional: Makes the sample page fill the window. 
        */
       html,
       body {
         height: 100%;
         margin: 0;
         padding: 0;
       }
       
       #description {
         font-family: Roboto;
         font-size: 15px;
         font-weight: 300;
       }
       
       #infowindow-content .title {
         font-weight: bold;
       }
       
       #infowindow-content {
         display: none;
       }
       
       #map #infowindow-content {
         display: inline;
       }
       
       .pac-card {
         background-color: #fff;
         border: 0;
         border-radius: 2px;
         box-shadow: 0 1px 4px -1px rgba(0, 0, 0, 0.3);
         margin: 10px;
         padding: 0 0.5em;
         font: 400 18px Roboto, Arial, sans-serif;
         overflow: hidden;
         font-family: Roboto;
         padding: 0;
       }
       
       #pac-container {
         padding-bottom: 12px;
         margin-right: 12px;
       }
       
       .pac-controls {
         display: inline-block;
         padding: 5px 11px;
       }
       
       .pac-controls label {
         font-family: Roboto;
         font-size: 13px;
         font-weight: 300;
       }
       
       #pac-input, #pac-input2 {
         background-color: #fff;
         font-family: Roboto;
         font-size: 15px;
         font-weight: 300;
         margin-left: 0px;
         padding: 0 11px 0 13px;
         text-overflow: ellipsis;
         width: 400px;
         margin-top: 10px;
        
       }
       
       
       #pac-input:focus, #pac-input2:focus {
         border-color: #4d90fe;
       }
       
       #title {
         color: #fff;
         background-color: #4d90fe;
         font-size: 25px;
         font-weight: 500;
         padding: 6px 12px;
       }
       
       #target {
         width: 345px;
       }
       #searchBoxes{
         display: flex;
         flex-direction: column;
       }
       .gmnoprint{
        display:none;
       }
       </style>
    <script>
    /**
        * @license
        * Copyright 2019 Google LLC. All Rights Reserved.
        * SPDX-License-Identifier: Apache-2.0
        */
       // @ts-nocheck TODO remove when fixed
       // This example adds a search box to a map, using the Google Place Autocomplete
       // feature. People can enter geographical searches. The search box will return a
       // pick list containing a mix of places and predicted search terms.
       // This example requires the Places library. Include the libraries=places
       // parameter when you first load the API. For example:
       // <script src="https://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY&libraries=places">
       function initAutocomplete() {
         const map = new google.maps.Map(document.getElementById("map"), {
           center: { lat: 43.6150, lng: -116.2023 },
           zoom: 10,
           mapTypeId: "roadmap",
         });
         // Create the search box and link it to the UI element.
        const input = document.getElementById("pac-input");
        const input2 = document.getElementById("pac-input2");
        const inputBoxesContainer = document.getElementById("searchBoxes");
        const searchBox = new google.maps.places.SearchBox(input);
        const searchBox2 = new google.maps.places.SearchBox(input2);

        map.controls[google.maps.ControlPosition.TOP_LEFT].push(inputBoxesContainer);
         // Bias the SearchBox results towards current map's viewport.
         map.addListener("bounds_changed", () => {
           searchBox.setBounds(map.getBounds());
           searchBox2.setBounds(map.getBounds());
         });
       
         let markers1 = [];
         let markers2 = [];
       
        function searchListener(MarkersArray, colorNum){
           const places = searchBox.getPlaces();
       
           if (places.length == 0) {
             return;
           }
       
           // Clear out the old markers.
           MarkersArray.forEach((marker) => {
             marker.setMap(null);
           });
           MarkersArray = [];
       
           // For each place, get the icon, name and location.
           const bounds = new google.maps.LatLngBounds();
       
           places.forEach((place) => {
             if (!place.geometry || !place.geometry.location) {
               console.log("Returned place contains no geometry");
               return;
             }
             
             // Create a marker for each place.
             let markerURL = "http://maps.google.com/mapfiles/ms/icons/orange-dot.png"; 
             if(colorNum===1){
                 markerURL = "http://maps.google.com/mapfiles/ms/icons/blue-dot.png";
                 console.log(colorNum);
             }else if(colorNum===2){
                 markerURL = "http://maps.google.com/mapfiles/ms/icons/red-dot.png";
                 console.log(colorNum);
             }else if(colorNum===3){
                 markerURL = "http://maps.google.com/mapfiles/ms/icons/pink-dot.png";
             }else if(colorNum===4){
                 markerURL = "http://maps.google.com/mapfiles/ms/icons/green-dot.png";
             }else if(colorNum===5){
                 markerURL = "http://maps.google.com/mapfiles/ms/icons/orange-dot.png";
             }

             MarkersArray.push(
                new google.maps.Marker({
                   position: place.geometry.location,
                   icon: {
                        url: markerURL+""
                    },
                   map,
                     })
             );
             if (place.geometry.viewport) {
               // Only geocodes have viewport.
               bounds.union(place.geometry.viewport);
             } else {
               bounds.extend(place.geometry.location);
             }
           });
           map.fitBounds(bounds);
         }

         searchBox.addListener("places_changed", () =>searchListener(markers1, 1));
         searchBox2.addListener("places_changed", () =>searchListener(markers2, 2));


         // Listen for the event fired when the user selects a prediction and retrieve
         // more details for that place.
         /*searchBox.addListener("places_changed", () => {
           const places = searchBox.getPlaces();
       
           if (places.length == 0) {
             return;
           }
       
           // Clear out the old markers.
           markers1.forEach((marker) => {
             marker.setMap(null);
           });
           markers1 = [];
       
           // For each place, get the icon, name and location.
           const bounds = new google.maps.LatLngBounds();
       
           places.forEach((place) => {
             if (!place.geometry || !place.geometry.location) {
               console.log("Returned place contains no geometry");
               return;
             }
       
             // Create a marker for each place.
             markers1.push(
                new google.maps.Marker({
                   position: place.geometry.location,
                   //label: "1",
                   icon: {
                             url: "http://maps.google.com/mapfiles/ms/icons/blue-dot.png"
                           },
                   map,
                     })
             );
             if (place.geometry.viewport) {
               // Only geocodes have viewport.
               bounds.union(place.geometry.viewport);
             } else {
               bounds.extend(place.geometry.location);
             }
           });
           map.fitBounds(bounds);
         });*/
         
         /* searchBox2.addListener("places_changed", () => {
           const places = searchBox2.getPlaces();
       
           if (places.length == 0) {
             return;
           }
       
           // Clear out the old markers.
           markers2.forEach((marker) => {
             marker.setMap(null);
           });
           markers2 = [];
         
       
           // For each place, get the icon, name and location.
           const bounds = new google.maps.LatLngBounds();
       
           places.forEach((place) => {
             if (!place.geometry || !place.geometry.location) {
               console.log("Returned place contains no geometry");
               return;
             }
       
             // Create a marker for each place.
             markers2.push(
             
                new google.maps.Marker({
                   position: place.geometry.location,
                   //label: "2",
                   icon: {
                             url: "http://maps.google.com/mapfiles/ms/icons/yellow-dot.png"
                           },
                   map,
                     })
       
             );
             if (place.geometry.viewport) {
               // Only geocodes have viewport.
               bounds.union(place.geometry.viewport);
             } else {
               bounds.extend(place.geometry.location);
             }
           });
           map.fitBounds(bounds);
         });*/
       }
       
       window.initAutocomplete = initAutocomplete;
        </script>
    <!-- jsFiddle will insert css and js -->
  </head>
  <body>
    <div id="searchBoxes">
        <input
        id="pac-input"
        class="controls"
        type="text"
        placeholder="Search Box 1"
      />
      <input
        id="pac-input2"
        class="controls"
        type="text"
        placeholder="Search Box 2"
      />
    </div>
    <div id="map"></div>

    <!-- 
     The `defer` attribute causes the callback to execute after the full HTML
     document has been parsed. For non-blocking uses, avoiding race conditions,
     and consistent behavior across browsers, consider loading using Promises
     with https://www.npmjs.com/package/@googlemaps/js-api-loader.
    -->
    <script
      src="https://maps.googleapis.com/maps/api/js?key=AIzaSyB41DRUbKWJHPxaFjMAwdrzWzbVKartNGg&callback=initAutocomplete&libraries=places&v=weekly"
      defer
    ></script>
  </body>
</html>